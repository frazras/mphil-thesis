\chapter{The \texttt{X10ABOT} Architecture, Design and Implementation}% (fold)
\label{cha:the_x10abot_architecture_design_and_implementation}
%%%%----------------------------------------------------
%We modelled our sensor and actuator ports after a similar design, we also took note of the software architecture and structured the \xten to be able to facilitate a virtual machine type plugin that can interpret the Lego NXT bytecode. We started work on this but realised that the magnitude of effort required was beyond the scope of this thesis. This bytecode interpreter was not complete but if this direction is pursued, integration should not be too difficult.
%%%%----------------------------------------------------


In this chapter we describe how we designed the components of the \xten robotics framework. We applied many of the design strategies that were introduced in chapter 2 in an effort to develop a state of the art robotics architecture. We extracted the most compelling features and combined them to create a modular, scalable and extensible system with the following components:
\begin{enumerate}
\item The Motherboard
\item The Daughterboard
\item The Peripheral Bus
\item Input and Output Ports
\item The Motherboard Library
\item Daughterboard Firmware
\item The Middleware
\end{enumerate}

%\section{Physical Setup} chapters should represent compoents of the system

% Chapter 3
Our research influenced and validated many of our design decisions for the components of the \xten architecture. We chose a combination of the best features of these technologies which we found to improve modularity, scalability and extensibility and combined them to construct our framework. It was also important that we kept the cost of implementation relatively inexpensive. These attributes represented common design patterns observed over a number of robotics projects, either for custom robots or as a part of the architecture for general purpose robotics kits. The actual implementation of these concepts included an \iic powered peripheral bus, separate modules to manage additional sensors and actuators, a middleware architecture, full featured sensor and actuator ports, just to name a few. We needed a robust architecture that provided more than just an increase in connection points for sensors and actuators. It was critically important that there was adequate hardware and software support for the large number of sensors and actuators.

The \xten framework is an architecture that is somewhat platform independent. However for the purpose of demonstration, we chose to implement it on the Arduino development board. Most of the concepts can be implemented on any modern microcontroller with a high speed serial interface and adequate I/O ports comparable to what is offered by the chips used in a standard Arduino. With a proper shield built on an Arduino running the \xten software, the entire controller would cost as little as \$30 USD. This would make the \xten a comparable kit when compared to the LEGO Mindstorms with respect to the number of ports for sensors and actuators. Boasting the additional capabilities of cost effective scalability, modularity and extensibility.
These features are not easily attained with a simple Arduino kit, the framework transforms the lowly Arduino into a capable robotics platform.



%%Impact or influence of the design decisions and how they were implemented

%User friendly:  Usable primary school to  graduate level roboticists
\newpage
\section{The Architecture} % (fold)
\label{sec:the_architecture}
Based on the design requirements listed above, we created an architecture that captured all the previously listed features without making any significant compromise on any. The \xten architecture implements previously outlined requirements at both the hardware and software level. It is comprised of a motherboard which is the main central controller. The motherboard is also the head of a distributed system of peripheral sensor and actuator boards called daughterboards. The daughterboards carry out a standard set of computations synonymous to a thin client, all connected across the central peripheral bus. The motherboard coordinates and controls all operations on the entire system and all operations are either initiated or terminated at the motherboard, except in the special instance when a daughterboard temporarily takes on the role of a motherboard for interrupt management. The motherboard hosts the main program for the robot application, the middleware and the extensible libraries to support various types of sensors and actuators. Each daughterboard is equipped with firmware to interpret and execute instructions given to it by the motherboard. Each daughterboard also provides multi-faceted sensor and actuator ports that can support a broad range of sensors and actuators. 

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{Figures/system_block_diagram.pdf}
    \caption{The components of the \xten Architecture}
  \end{center}
\end{figure}

\subsection{The Hardware Architecture} % (fold)
\label{sub:the_hardware_architecture}
The hardware aspect of the \xten framework consists of three major components. These are the motherboard, daughterboard and the peripheral bus which connects them all. Below we will describe in detail how each component functions and how they relate to each other in accomplishing the goals of the architecture.



	\subsubsection{The Motherboard} % (fold)
	\label{ssub:the_motherboard}
	The motherboard is a physical component of the robotics platform and operates as the single central processing unit. It controls the flow of data and instructions across the entire \xten architecture. All robot control instructions written by the robotics developer are hosted on the motherboard. The instruction logic is processed on the motherboard, however the actual sensor or actuator operations are dispatched to daughterboards as microcode instructions. These microcode instructions are then subsequently interpreted and their operations executed by sensors and actuators. As the main computational entity in the \xten architecture, the motherboard is responsible for executing most of the decision logic, heavy computing tasks, actuating the output devices and interpreting information from input devices based on its preprogrammed set of instructions.
The motherboard acts as the head of the distributed system of peripheral boards. Sensors and actuators are hosted by daughterboards which are connected to the motherboard via the peripheral bus. 
 
	% subsubsection the_motherboard (end)
	
	\subsubsection{The Peripheral Bus} % (fold)
	\label{ssub:the_peripheral_bus}
	
	\begin{figure}[h]
	  \begin{center}
	    \includegraphics[width=1.0\columnwidth]{Figures/pbus.pdf}
	    \caption{The serial communication peripheral \iic bus}
	  \end{center}
	\end{figure}

	The Peripheral Bus is the central medium that connects the motherboard to one or more daughterboards and facilitates the communication of data and instructions between them. The peripheral bus is implemented using the \iic serial communication protocol. 
	
	% subsubsection the_peripheral_bus (end)
	All communication on the \iic bus is initiated by the bus master or, as in our case, the motherboard. This is not suitable in all situations, e.g.: when a sensor detects an input that needs to be processed immediately. Even if all the daughterboards are periodically polled, the elapsed time may cause the sensor data to become invalid or ineffective. That is why we utilized the multi-master capability of the \iic peripheral bus to accomplish arbitration. The motherboard has primary control over the peripheral bus but can give up the control to any daughterboard that wants to gain temporary bus-master status. 

	Bus arbitration by the daughterboard is trivial and is accomplished by simply importing both the functionality for the motherboard and daughterboard. Each daughterboard would then have to know the motherboard's \iic address and make the same function calls a motherboard would for the purpose of sending data when it is ready to transmit.
	
	The peripheral bus allows for easy connection of additional devices because they can be daisy-chained onto each other reducing the need for extensive and confusing wiring. Since the peripheral bus is an \iic bus, it is compatible with ``non-daughterboard'' \iic compatible devices. The framework was designed to accommodate sensors and actuators as specialised, single device daughterboards. This was also a method of ensuring maximal extensibility.
	
	There is one exception to the use of the \iic bus as the main peripheral bus, this involves the use of an internal daughterboard. We will expound on this concept in the next section.

	The peripheral bus is not used to transmit power from the motherboard. Each daughter board is meant to be individually powered due to the possible varied power requirements of its resident sensors and actuators. This also makes scalability far less complicated. There needs to be no consideration of the wide range of possible power requirements.
	
	\subsubsection{The Daughterboard} % (fold)


	\label{ssub:the_daughterboard}
	The daughterboard is the secondary computing device in the \xten robotics architecture. It hosts all the sensors and actuators that carry out the tasks of each robotics project. Although the daughterboard is a second tier processing component in the X10ABOT architecture, its operation is not trivial. The daughterboard is given the major task of interpreting instructions sent from the motherboard over the peripheral bus and executes them with sensors and actuators. Sensors and actuators are connected to sensorï¿¼and actuator ports respectively and respond to the assertions placed upon them by the daughterboard. Daughterboards carry out simple low level operations and won't require a significant amount of processing power. There are however a few basic features that every daughterboard must possess. All daughterboards must be able to communicate over an \iic bus and do basic digital and analog input and output. These features are very common in most microcontrollers and can be implemented without a significant cost or effort.
	As a member of the peripheral bus, each daughterboard must possess a unique address that the developer is aware of, it also must have knowledge of the motherboard's address. A daughterboard will need the motherboard's address whenever it has time critical data that needs to be sent to the motherboard. Using bus arbitration, the daughterboard tries to temporarily claim the bus-master role in order to quickly pass its data to the motherboard, it would then immediately switch back to its original role.
	\subsubsection{Internal Daughterboard} % (fold)
	\label{ssub:internal_daughterboard}
	
	% subsubsection internal_daughterboard (end)
	On a typical motherboard circuitry, the only external I/O pins that are generally utilized are SCK and SCL that operate the \iic protocol. This leaves a large number of unused IO pins that could have otherwise been used for some kind of operation. We then came up with a method for utilising these extra resources without breaking the design of the architecture. We designed a virtual, internal daughterboard, that uses the same microprocessor and physical board as the motherboard. This internal daughterboard is assigned with address number zero(0). All its data and instructions are communicated using direct parameter passing instead of across the peripheral bus. This particular exception is abstracted by the middleware described in section~\ref{ssub:middleware} and is totally hidden from both the motherboard and the internal daughterboard.

	We do not integrate power as a part of the peripheral bus, each daughterboard is independently powered and the ports are designed to allow for each connected device on the daughterboard to use their own isolated power source.
	
	\begin{figure}[h]
	  \begin{center}
	    \includegraphics[width=1.0\columnwidth]{Figures/db.pdf}
	    \caption{The daughterboard slave module}
	  \end{center}
	\end{figure}
	
	% subsubsection the_daughterboard (end)
	\subsubsection{Sensor \& Actuator Ports} % (fold)
	\label{ssub:input_&_output_ports}
	All sensors and actuators connect to daughterboards to send and receive data through their respective sensor and actuator ports. Ports are specially designed interfaces that were made to facilitate various types of sensors and actuators. They were built by considering the most common technological requirements of popular sensors and actuators. The sensor and actuator ports are made up of five(5) and six(6) pins respectively.

\begin{figure}[h]
  \begin{center}
    \includegraphics[width=0.5\columnwidth]{Figures/Ports.pdf}
    \caption{The sensor and the actuator ports}
  \end{center}
\end{figure}

 A sensor port is comprised of five(5) pins: power, ground, an analog input, and two digital I/O pins. The analog input pin is able to read voltages from analog sensors e.g. touch, light and sound sensors. The digital I/O pins can support active and passive digital sensors such as ultrasonic range-finders,  passive infrared(PIR) sensors and Radio-frequency identification(RFID) sensors. The power and ground pins provide electrically isolated power for the sensors (typically 3 or 5 volts, but in principle the power could be different from the microcontroller's voltage requirements).

An actuator port is comprised of 6 pins: power, ground, two (2) Pulse Width Modulation (PWM) output pins and two (2) digital I/O pins. The PWM signals allow support for servo motors as well as for adjusting power levels on output devices. The digital I/O pins are able to drive DC motor H-bridges or to be read as digital encoder signals. Like the sensor ports, the power supply for output ports is also electrically isolated from that of the microcontroller. This is particularly necessary when powering motors to prevent damage to the controller and other electronics.

A power bus runs through each daughterboard, connecting all the power pins of its ports. This power bus is meant to supply an alternate power source to the attached sensors and actuators. This alternate power source may or may not be suitable for powering the internal circuitry on the daughterboard, therefore, it is properly isolated. A hardware implementation of the power bus can include a jumper device to switch the power source from the basic 5V supply provided by the system to an external supply at the power specification of the sensor or actuator. 
	% subsubsection input_&_output_ports (end)
% subsection the_hardware_architecture (end)

\subsection{The Software Architecture} % (fold)
\label{sub:the_software_architecture}
The \xten hardware is managed by software distributed across both the motherboard and daughterboard. The software is responsible for the efficient operation of all components involved in the system. The software managing the architecture can be classified into four categories: firmware, middleware, device libraries and application software. The application software, libraries and middleware reside on the motherboard while the daughterboards host the firmware. Unlike the hardware architecture, we will be describing the software with direct relation to our particular implementation on the Arduino development board.
	

	\subsubsection{The Motherboard Library} % (fold)
	\label{ssub:the_motherboard_library}

	
	The motherboard robotics library is a tool-chain of functions written specifically for robotics applications. We defined and developed an extensible library of useful robotics operations for common devices and general sensors and actuators. They can be composed to control the behaviour of a robot. Our particular implementation made use of the Arduino platform which supports the addition of third-party libraries. This allows for robotics developers to take advantage of the usability of the Arduino development platform while capitalising on the usefulness of a robotics-specific set of operations implemented in the library.
The library was designed not only to provide common robotics functionality to its users but to also make programming large robots with many sensors and actuators less of a hassle especially when taking advantage of the scalability and modularity of the entire platform.

	\begin{figure}[h]
	  \begin{center}
	    \includegraphics[width=0.7\columnwidth]{Figures/system.pdf}
	    \caption{The \xten software architecture}
	  \end{center}
	\end{figure}
	
	


	% subsubsection the_motherboard_library (end)
	\subsubsection{Application Software} % (fold)
	\label{ssub:application_software}
	Code written by users that takes advantage of the features of the \xten architecture to complete a particular task is considered to be application software. The main purpose for creating a robotics framework is to allow the end user to have a gratifying experience when developing software for their robotics project. We wanted to provide the users with the tools that would allow them to build more interesting robotics projects, without the usual limitations of scale or complexity that often follow. 
	
	We used Arduino's \emph{Processing} language as our choice for the implementation of the framework. It is known to be very easy to learn and use and also has a supporting IDE that allows the user to get up and running in a short period of time. 
	Applications will be written in a C-like syntax and compiled to run on an Arduino board. This is a familiar interface for many roboticists because Arduino is a very common robotics development platform.
	% subsubsection application_software (end)
	
	\subsubsection{The Daughterboard Firmware} % (fold)
	\label{ssub:the_daughterboard_firmware}
	The daughterboard firmware provides a standard interface from all daughterboards to their motherboard. All instructions to control or access sensors and actuators are communicated to it via the peripheral bus. These instructions are written as microcode abstractions of the hardware and need to be translated to actual assertions on the devices. Each abstracted command in the motherboard's \xten Library is translated into one or more microcode hardware instructions. Microcode instructions are carried out sequentially by the daughterboards to manipulate the physical hardware components that are attached to their ports. The microcode instructions define a universal set of hardware operations. When these are put together, they can control most typical robotics sensors or actuators.
	
 Our system was designed to support as many types of sensors and actuators as possible. To achieve this, we had to find a common denominator for all sensors and actuators. Sensors and actuators have many requisite hardware technologies that need to be supported. We realised that these technologies were subsets or a combination of a finite set of operations. Technologies such as pulse width modulation, hardware interrupts, digital input/output and analog input are just some of the basic ones used by most sensors and actuators. We determined that if we could define this set of hardware operations, we could control most if not all sensors and actuators. This would allow extensibility to currently existing and possibly new types of sensors and actuators.

		The microcode instructions specified for daughterboards, provide different means of interacting with each port (see Table~\ref{tab:microcode}).


	\begin{table}[h] 
        \centering
          \scriptsize {%         
            
	      \begin{tabular}{|l|l|l|}
	      	\hline
	      	\textbf{Commands} &  \multicolumn{2}{l|}{\textbf{Parameters}}\\\hline
	      	digitalOut & \multicolumn{2}{l|}{state, db\_address, port\_number, pin\_select}\\\hline
			digitalIn & \multicolumn{2}{l|}{db\_address, port\_number, pin\_select}\\\hline
			pwm & \multicolumn{2}{l|}{pwm\_select, db\_address, port\_number, duty\_cycle}\\\hline
			analog & \multicolumn{2}{l|}{db\_address, port\_number}\\\hline
			\toprule 
	        \multicolumn{3}{c}{\textbf{Parameter Definitions}} \\\hline
            \textbf{Format} & \textbf{Name} & \textbf{Description}\\\hline
			byte & state & The state of the digital pin, HIGH(2), LOW(1), INPUT(0) \\\hline
			byte  & db\_address & The daughterboard address between 7 and 120, 0 for internal \\\hline
			byte  & port\_number & The daughter board's port number connected to the device \\\hline
			byte  & pin\_select & Choose which of the I/O pins on the port to use A(0) or B(1) \\\hline
			byte  & pwm\_select & Choose which of the PWM pins on the port to use A(0) or B(1) \\\hline
			byte  & duty\_cycle & Specify the duty cycle as a number between 0 and 255 \\\hline
           % \multicolumn{3}{c}{Unimplemented Features} \\\hline
            %I$^{2}$C & Read/Write & Serial Data \\\hline 
            %RS-232 & Read/Write & Serial Data \\\hline 
            %Watch & Rising/Falling Edge & Threshold Value\\\hline 
            %Watch & Threshold & Greater/Less than\\\hline 
            \end{tabular} 
            }
	  \caption{The complete set of hardware operations supported by the
	    microcode interface to the daughterboards. These basic commands are the building blocks of all operations sent between the motherboard and daughterboard.}
	  \label{tab:microcode}
	\end{table}
	\normalsize


	The firmware on the daughterboards will interpret these instructions and execute hardware procedures. These instructions are asserted to the standard sensor and actuator ports which are composed of pins, each with their specific purpose. Sensors and actuators are connected to their respective ports and respond to the assertions placed upon them by the daughterboard. Figure~\ref{fig:sequence} shows a sequence diagram outlining the process from initializing an actuator in code to asserting a digital operation on the actuator.
	
 The current microcode instructions include analog, digital and PWM and are the basic building blocks used to create more complex operations when combined or used with other computations. If a future sensor or actuator uses an incompatible operation, then a firmware upgrade which would include the new microcode instructions would have to be developed in order to interface with the new device (assuming that it could be made to be hardware compatible with the port). The microcode instructions are made to be very generic, ensuring compatibility with as many sensors and actuators as we could find at the time of design.


    \begin{figure}[H]
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{Figures/sequence.pdf}
    \caption{The components of the \xten Architecture}
    \label{fig:sequence}
  \end{center}
\end{figure}


	The motherboard implements a number of functions that allow the libraries to utilize microcode instruction in the development of device libraries. These instructions are passed to the daughterboard where they are interpreted and executed. Figure~\ref{code:micro} shows a few of the microcode instructions used in the \xten library and their related parameters.
	
\begin{figure}[h]
\footnotesize
{\fontsize{8}{6}\selectfont
\begin{minted}[bgcolor=bg,baselinestretch=1,frame=lines,framesep=2mm,label={Microcode Implementation}]{c}

/**
 * Asserts a state to a Digital IO pin
 *
 * @param  byte  state  The state of the digital pin, HIGH(2), LOW(1), INPUT(0)
 * @param  byte  db_address The daughterboard address between 7 and 120, 0 for motherboard
 * @param  byte  port_number the daughter board's port number connected to the device
 * @param  byte  pin_select choose which of the I/O pins on the port to use A(0) or B(1)
 * @return void
 */
void X10ABOT_MB::digitalOut(byte state, byte db_address, 
                            byte port_number, byte pin_select){
  byte microcode[] =   {FN_IO+state,db_address,
                          ((port_number-1)<<1)+pin_select,incr_instr_seq()};
  dispatch(microcode, sizeof(microcode));

}
byte X10ABOT_MB::digitalIn(byte db_address, byte port_number, byte pin_select){
  byte seq_num = incr_instr_seq();
  byte microcode[] =   {FN_IO+IN,db_address,((port_number-1)<<1)+pin_select,seq_num};
  dispatch(microcode, sizeof(microcode));
   return requestHandler(microcode, 2,seq_num);
}
/**
 * Asserts a PWM signal to a pin
 *
 * @param  byte  pwm_select choose which of the PWM pins on the port to use A(0) or B(1)
 * @param  byte  db_address The daughterboard address between 7 and 120, 0 for motherboard
 * @param  byte  port_number the daughter board's port number connected to the device
 * @param  byte  duty_cycle specify the duty cycle as a number between 0 and 255
 * @return void
 */
void X10ABOT_MB::pwm(byte pwm_select, byte db_address, 
                        byte port_number, byte duty_cycle){
  byte microcode[] =   {FN_PWM,db_address,((port_number-1)<<1)+pwm_select,
                          incr_instr_seq(),duty_cycle};
  dispatch(microcode, sizeof(microcode));
}

/**
 * Reads the state from an Analog pin
 *
 * @param  byte  db_address The daughterboard address between 7 and 120, 0 for motherboard
 * @param  byte  port_number the daughter board's port number connected to the device
 * @return int
 */
int X10ABOT_MB::analog(byte db_address, byte port_number){
  byte seq_num = incr_instr_seq();
  byte microcode[] =   {FN_ANALOG,db_address,((port_number-1)<<1),seq_num };
  dispatch(microcode, sizeof(microcode));
  return requestHandler(microcode, 6,seq_num);
}


\end{minted}
}
\caption{Example implementation of the \xten microcode instructions used in the device libraries} \label{code:micro}
\end{figure}	


	For every event on the daughterboard that is to be triggered, a microcode instruction is sent from the motherboard. The format of the instructions are as follows (see Table~\ref{tab:mc-structure}): The first four bits of the first byte define the instructions to be executed and the next four bits define the specific operation for that instruction. The second byte specifies the daughterboard address, the third byte uses its leftmost bit to determine whether it is addressing a sensor or actuator port. The next six bits on the third byte form the port number and the rightmost bit is used for the pin selection. Each transmitted instruction has a sequence number that is assigned to each microcode instruction. Some instructions require additional data to complete their operations. The microcode format provides a sequence of data bytes that can be of arbitrary length. It was created to be used in operations where a lot of data may be transmitted e.g RS-232. Table~\ref{tab:mc-structure} shows the structure of a typical microcode instruction.
	
	\begin{table}[h] \scriptsize {%
	    \newcommand{\mc}[3]{\multicolumn{#1}{#2}{#3}} 
	    \begin{center}
	      \begin{tabular}{|lll|}\hline %\mc{3}{|c|}{\textbf{}} \\\hline
	        \mc{1}{|l|}{Byte 1:} & \mc{1}{l|}{XXXX - - - -} & \mc{1}{l|}{FUNCTION BYTE}
	        \\\hline \mc{1}{|l|}{Byte 1:} & \mc{1}{l|}{- - - - XXXX} & OPERAND BYTE
	        \\\hline \mc{1}{|l|}{Byte 2:} & \mc{1}{l|}{XXXXXXXX} & D.B. SELECTION
            \\\hline \mc{1}{|l|}{Byte 3:} & \mc{1}{l|}{X - - - - - - -} & PORT TYPE
	        \\\hline \mc{1}{|l|}{Byte 3:} & \mc{1}{l|}{- XXXXXX -} & PORT SELECTION
			 \\\hline \mc{1}{|l|}{Byte 3:} & \mc{1}{l|}{- - - - - - - X} & PIN SELECTION
			 \\\hline \mc{1}{|l|}{Byte 4:} & \mc{1}{l|}{XXXXXXXX} & INSTRUCTION SEQUENCE NUMBER
	        \\\hline \mc{1}{|l|}{Byte(s) 4+n} & \mc{1}{l|}{XXXXXXXX } & DATA
	        BYTES; n\texttt{>} 0
	        \\\hline \end{tabular}
	    \end{center} }
	  \caption{Byte layout for transmitted microcode} \label{tab:mc-structure}
	  
	\end{table}
	\normalsize
	
	In Figure~\ref{code:instr} it can be further observed how these microcode instructions are used to create operations for the generic Actuator class.
The code shows how microcode instructions are used to compose particular robotics instructions in the \xten architecture. Here the I/O method accept HI and LO values according to the pins (\textbf{A and B}) on which the instruction will be asserted. The pwm instructions (\textbf{pwm\_a and pwm\_b}), named after the pwm pin which they assert, require the \textbf{power} parameter that is passed as an argument to the function.
	
    \begin{figure}
    \footnotesize
    {\fontsize{8}{6}\selectfont
    \begin{minted}[bgcolor=bg,baselinestretch=1,frame=lines,framesep=2mm,label={Actuator Class Implementation}]{c}

    
    /*
    * Sets digital pin values to High or Low
    */
    void Actuator::setDigital(byte pin_a, byte pin_b){
      actuator.digitalOut(pin_a,_db,_port,A);
      actuator.digitalOut(pin_b,_db,_port,B);
    }

    /*
    * Sets analog pin to a value between 0 and 100
    */
    void Actuator::pwm_a(byte power){
      actuator.pwm(A, _db, _port, 255*power/100);
    }

    void Actuator::pwm_b(byte power){
      actuator.pwm(B, _db, _port, 255*power/100);
    }

    \end{minted}
    }
    \caption{Example of the Actuator class methods that uses microcode to represent general operations on an actuator} \label{code:instr}
    \end{figure}
    
	The purpose of the daughterboard is to interpret these high-level instructions from the motherboard and execute them on the respective sensor or actuator irrespective of the hardware specifics of the daughterboard. This ensures that high level language instructions sent from the motherboard remains platform independent.
	
	
	% subsubsection the_daughterboard_firmware (end)
	
	\subsubsection{Middleware} % (fold)
	\label{ssub:middleware2}

	A middleware architecture is used to hide the low-level details of the communication interface between the components that make up a distributed robotics system. This level of abstraction allows for an interface between the main controller and the sensors and actuators which supports a high level definition of their operations. 
	
	The aspect of the \xten architecture that transports the microcode from the libraries of the motherboard to the interpreter of the daughterboard is considered to be our middleware. Each microcode instruction formats the byte string as described in Table ~\ref{tab:mc-structure}. The microcode then performs one or more of a series of dispatch and request events between the motherboard and the daughterboard. The daughterboard also initiates data transfers as well for certain special cases. All these operations are managed by the middleware. The dispatch and request functions are used to pass data across the peripheral bus.
%\label{code:reqhandler}
%\label{code:dispatch}
	\begin{figure}
    \footnotesize
    {\fontsize{8}{6}\selectfont
    \begin{minted}[bgcolor=bg,baselinestretch=1,frame=lines,framesep=2mm,label={Middleware Dispatch Function Implementation}]{c}

/**
 * Dispatches microcode to the internal/external daughterboard for execution
 *
 * @param  byte*  microcode  This is an array of microcode instructions to be sent
 * @param  byte   byte_length the size in bytes of the microcode instruction
 * @return void
 */
void X10ABOT_MB::dispatch(byte* microcode, byte byte_length){
  if (microcode[D_B_SELECTION]==0){ //If 0 use internal Daughterboard
    db.localReceive(microcode, byte_length); //do operation locally
  }
  else{
    Wire.begin();   //Initiate TWI interface
    //Set TWI Transmission Speed
    TWBR=0x13; // (DEC = 19) ~300000L
   
    Wire.beginTransmission(microcode[D_B_SELECTION]); // transmit to device #x
    Wire.write(microcode, byte_length);       // sends all bytes
    i2cStatusLog(Wire.endTransmission()); // stop transmitting and log output
  }
  dispatchDataLog(microcode, sizeof(microcode));
}
	\end{minted}
    }
    \caption{Example of the Middleware Dispatch Function Implementation used to determine the transport interface and protocol of the operations between the motherboard and daughterboard.} \label{code:dispatch}
    \end{figure}

\begin{figure}
    \footnotesize
    {\fontsize{8}{6}\selectfont
    \begin{minted}[bgcolor=bg,baselinestretch=1,frame=lines,framesep=2mm,label={Middleware Request Handler Function Implementation}]{c}


/**
 * Sends requests using microcode to the internal/external daughterboard for execution
 * @param  byte byte_length the size in bytes of the microcode instruction
 * @return void
 */
int X10ABOT_MB::requestHandler(byte* microcode, byte byte_length, byte seq_num){
  for (int i = 0; i < 3; ++i){
    if (_lookup[i][0]==seq_num){
      return _lookup[i][1];
    }
  }
  if (microcode[D_B_SELECTION]==0){
    byte return_array[6];
    db.localRequest(return_array);
    byte output[5];
    if (return_array[0]!=seq_num){      
         //loop into cache
      _lookup[_lookup_index][0]= return_array[0];
      _lookup[_lookup_index][1]=return_array[1];
      if (_lookup_index>2){
        _lookup_index = 0;
      }else{
        _lookup_index++;
      }
    }else{      
      for (int y=0; y<6;y++){
        output[y]=return_array[y+1];
      }
      int x = atoi((char*)output);
      return x;
    }
  }
  else{
    TWBR = 0x1B; // (DEC = 27) ~230000L
    Wire.requestFrom((int)microcode[D_B_SELECTION], 6);
    if(Wire.available()){    // slave may send less than requested
      byte c = Wire.read();
      if (c!=seq_num){
         //loop into cache
        _lookup[_lookup_index][0]= c;
        _lookup[_lookup_index][1]=Wire.read();
        if (_lookup_index>2){
            _lookup_index = 0;
          }else{
            _lookup_index++;
          }
        }else{
          byte result[5];
          byte x=0;
        while(Wire.available()){    // slave may send less than requested
          result[x]=Wire.read();
          x++;
        }
        int w = atoi((char*)result);
        return w;
      }
    }
    dispatchDataLog(microcode, sizeof(microcode));
  }
}
\end{minted}
    }
    \caption{Example of the Middleware Request Handler Function Implementation used to determine the transport interface and protocol of the operations between the motherboard and daughterboard.} \label{code:reqhandler}
    \end{figure}


	% subsubsection middleware (end)
	
	\subsubsection{Extending the Library} % (fold)
	\label{ssub:extending_the_library}
	
	To allow for easy extensibility and to support new hardware, the \xten software architecture was designed to allow user extensible libraries. A library defines a set of instructions used to control a hardware device.
	
	A new type of sensor or actuator can be supported by adding it as a device library on the \xten motherboard. Creating a new device specification can be done without the need to understand any low level device specific coding, since all the configurations are abstracted for easier programming. Extensibility is therefore achieved through high-level abstraction of low level hardware components.
    Figure~\ref{code:extlib} shows the code for a new temperature sensor (thermistor) library that was created to extend the \xten support for a new device. The thermistor required specialised manipulation of the analog value it received from the sensor to produce a useful value in Celsius or Fahrenheit.
    
    \begin{figure}
    \footnotesize
    {\fontsize{8}{6}\selectfont
    \begin{minted}[bgcolor=bg,baselinestretch=1,frame=lines,framesep=2mm,label={Actuator Class Implementation}]{c}

    #include "../X10ABOT_MB.h"
    #include <math.h>
    class Thermistor: public Sensor
    {
      private:
        byte _db, _port;
      public:
        Thermistor(byte db_address, byte port_number):Sensor(_db, _port){
          _db = db_address;
          _port = port_number;
        }
        ~Thermistor(){};
        double readThermistorCelsius() {
        \end{minted}
        \begin{minted}[bgcolor=hilite,baselinestretch=1]{c}
            //The analog microcode requests the raw sensor value
            int RawADC = analog(_db,_port); 
        \end{minted}
        \begin{minted}[bgcolor=bg,baselinestretch=1]{c}
            double Temp;
            Temp = log(((10240000/RawADC) - 10000));
            Temp = 1/(0.001129148+(0.000234125+(0.0000000876741*Temp*Temp))*Temp);
            Temp = Temp - 273.15;            // Convert Kelvin to Celsius
            return Temp;
        }
        double readThermistorFarenheit() {
        // Convert Celsius to Fahrenheit
            return (readThermistorCelsius()* 9.0)/ 5.0 + 32.0;
        }
    };

    \end{minted}
    }
    \caption{Thermistor library showing how a sensor can be supported through the extensibility features of the \xten architecture} \label{code:extlib}
    \end{figure}
    
    
	Both the hardware and software allow for inclusion of new and cutting edge technologies by utilising the simple idea of composition of low level microcode instructions. Many seemingly complex protocols or devices operate using only a few simple fundamental electronic operations defined by our microcode instructions. By creating a set of instructions that utilize these fundamental operations, any composite methods can be formed to complete most electronic tasks. For example: to operate an h-bridge, to control a DC motor, this requires a particular set of configurations of the digital I/O pins in their HI or LOW state, the configurations determine the operating mode: forward, reverse or stop. It may also require a pulse width modulation input to determine the motor's speed. These could be composed as a single library for the device. The \xten system architecture was designed to facilitate device libraries which operate in a similar sense as hardware drivers for computer peripherals. A driver typically communicates with the device through a communication subsystem to which the hardware connects.	
	% subsubsection extending_the_library (end)
	
	%\subsubsection{Multitasking} % (fold)
	%\label{ssub:multitasking}
	
	%Another major aspect of the software system is its ability to execute simultaneous tasks. This was provided by the LEGO\textregistered  Mindstorms\textregistered  NXT platform and implemented in the X10ABOT robotics platform using the FreeRTOS real time scheduler. FreeRTOS is a tried and tested open source system which offers a very fast and efficient means of handling multiple tasks and timing operations.
	% subsubsection multitasking (end)
	
	%\subsubsection{The X10ABOT LEGO VM} % (fold)
	%\label{ssub:the_x10abot_lego_vm}
	%There has been significant work toward the creation of a LEGO\textregistered  Mindstorms\textregistered  NXT virtual machine which will operate on top on the X10ABOT Library. User program code in the form of bytecode will be interpreted and executed with equivalent library commands. Many of the limitations in the hardware of the NXT are not enforced in its bytecode, therefore it may have the ability to utilize the extra sensors and actuator ports provided by the X10ABOT Library.
	% subsubsection the_x10abot_lego_vm (end)
	
% subsection the_software_architecture (end)

% section the_architecture (end)

\section{The Arduino Implementation} % (fold)
\label{sec:the_arduino_implementation}
\xten is a robotics architecture that is indifferent to any particular hardware system. We endeavoured to create an architecture that had very few hardware specific restrictions that would force the developer to chose one hardware platform over another. We also tried to create an architecture that was capable of running on systems as simple as 8-bit micro-controllers. What we found was that a majority of hobbyist roboticists and robots used in school competitions tended to use 8-bit microcontrollers. However, many of the major notable robotics architectures were built on top of a full featured 32 or 64-bit processing systems. The architecture will however be able to scale up to a full scale 32 or 64-bit computer. This will allow for more complex programs to be written with more processor and hardware intensive operations. The most basic requirements for any implementation of the \xten architecture is a microprocessor which has the ability to perform digital and analog input and output. In this case, one controller will operate as both motherboard and daughterboard. In order to support external daughterboards, each microcontroller must have support for the \iic protocol in addition to the minimum requirements listed above.

The Arduino embedded system framework is a very active project, and it is notable for keeping at the cutting edge of embedded development. The framework is platform independent and currently deployed on a variety of processors including Atmel's AVR 8-bit and 32-bit ARM processors. There are even a few other companies including Microchip who have adopted the Arduino framework for their 32-bit processors as well. 
The \xten software was written with the Processing language supported by Arduino which is a derivative of C++. This allowed us to take advantage of many of C++'s high level language features including class hierarchy which is the basis of how development for the motherboard libraries are done. Arduino also comes with a cross platform IDE that allows development on all the major operating systems.

The Arduino platform provides very inexpensive hardware that can be used for both motherboard and daughterboard. They were designed for physical add-ons called shields which are convenient connection boards that can host auxiliary circuitry like port headers, external power and H-bridges. These shields are perfect platforms for the custom designed port of the \xten daughterboards.

% section the_arduino_implementation (end)

